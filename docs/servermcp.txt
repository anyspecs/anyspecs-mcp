erver Concepts

Copy page  复制页面

Understanding MCP server concepts
理解 MCP 服务器概念

MCP servers are programs that expose specific capabilities to AI applications through standardized protocol interfaces. Each server provides focused functionality for a particular domain.
MCP 服务器是程序，它们通过标准协议接口向 AI 应用程序展示特定功能。每个服务器为特定领域提供专注的功能。
Common examples include file system servers for document management, email servers for message handling, travel servers for trip planning, and database servers for data queries. Each server brings domain-specific capabilities to the AI application.
常见的例子包括用于文档管理的文件系统服务器、用于消息处理的电子邮件服务器、用于行程规划的旅行服务器以及用于数据查询的数据库服务器。每台服务器为 AI 应用带来特定领域的功能。
​
Core Building Blocks  核心构建模块
Servers provide functionality through three building blocks:
服务器通过三个构建模块提供功能：
Building Block  构建模块	Purpose  目的	Who Controls It  谁控制它	Real-World Example  现实世界示例
Tools  工具	For AI actions  用于 AI 操作	Model-controlled  模型控制	Search flights, send messages, create calendar events
搜索航班、发送消息、创建日历事件
Resources  资源	For context data  用于上下文数据	Application-controlled  应用程序控制	Documents, calendars, emails, weather data
文档、日历、电子邮件、天气数据
Prompts  提示	For interaction templates
用于交互模板	User-controlled  用户控制	”Plan a vacation”, “Summarize my meetings”, “Draft an email”
“计划一次假期”，“总结我的会议”，“起草一封电子邮件”
​
Tools - AI Actions  工具 - AI 操作
Tools enable AI models to perform actions through server-implemented functions. Each tool defines a specific operation with typed inputs and outputs. The model requests tool execution based on context.
工具使 AI 模型能够通过服务器实现的函数执行操作。每个工具定义了一个具有类型输入和输出的特定操作。模型根据上下文请求工具执行。
​
Overview  概述
Tools are schema-defined interfaces that LLMs can invoke. MCP uses JSON Schema for validation. Each tool performs a single operation with clearly defined inputs and outputs. Most importantly, tool execution requires explicit user approval, ensuring users maintain control over actions taken by a model.
工具是按模式定义的接口，LLMs 可以调用。MCP 使用 JSON Schema 进行验证。每个工具执行单个操作，具有明确定义的输入和输出。最重要的是，工具执行需要明确用户批准，确保用户对模型采取的操作保持控制。
Protocol operations:  协议操作：
Method  方法	Purpose  目的	Returns  返回
tools/list	Discover available tools  发现可用工具	Array of tool definitions with schemas
工具定义数组及模式
tools/call	Execute a specific tool  执行特定工具	Tool execution result  工具执行结果
Example tool definition:  示例工具定义：

Copy
{
  name: "searchFlights",
  description: "Search for available flights",
  inputSchema: {
    type: "object",
    properties: {
      origin: { type: "string", description: "Departure city" },
      destination: { type: "string", description: "Arrival city" },
      date: { type: "string", format: "date", description: "Travel date" }
    },
    required: ["origin", "destination", "date"]
  }
}
​
Example: Taking Action  示例：采取行动
Tools enable AI applications to perform actions on behalf of users. In a travel planning scenario, the AI application might use several tools to help book a vacation.
工具使 AI 应用程序能够代表用户执行操作。在一个旅行规划场景中，AI 应用程序可能会使用多个工具来帮助预订假期。
First, it searches for flights using
首先，它使用

Copy
searchFlights(origin: "NYC", destination: "Barcelona", date: "2024-06-15")
searchFlights queries multiple airlines and returns structured flight options. Once flights are selected, it creates a calendar event with
向多家航空公司查询，并返回结构化的航班选项。一旦选定航班，它会创建一个日历事件用

Copy
createCalendarEvent(title: "Barcelona Trip", startDate: "2024-06-15", endDate: "2024-06-22")
to mark the travel dates. Finally, it sends an out-of-office notification using
标记旅行日期。最后，它使用

Copy
sendEmail(to: "team@work.com", subject: "Out of Office", body: "...")
to inform colleagues about the absence.
发送自动回复通知，告知同事自己的缺席。
Each tool execution requires explicit user approval, ensuring full control over actions taken.
每执行一个工具都需要用户明确批准，确保对所采取的操作有完全控制权。
​
User Interaction Model  用户交互模型
Tools are model-controlled, meaning AI models can discover and invoke them automatically. However, MCP emphasizes human oversight through several mechanisms. Applications should clearly display available tools in the UI and provide visual indicators when tools are being considered or used. Before any tool execution, users must be presented with clear approval dialogs that explain exactly what the tool will do.
工具由模型控制，这意味着人工智能模型可以自动发现和调用它们。然而，模型上下文协议强调通过多种机制实现人工监督。应用程序应在用户界面中清晰地显示可用工具，并在考虑或使用工具时提供视觉指示。在任何工具执行之前，必须向用户展示清晰的批准对话框，解释该工具将具体执行什么操作。
For trust and safety, applications often enforce manual approval to give humans the ability to deny tool invocations. Applications typically implement this through approval dialogs, permission settings for pre-approving certain safe operations, and activity logs that show all tool executions with their results.
为了信任和安全，应用程序通常强制执行手动批准，以赋予人类拒绝工具调用的能力。应用程序通常通过批准对话框、预先批准某些安全操作的权限设置以及显示所有工具执行及其结果的活动日志来实现这一点。
​
Resources - Context Data  资源 - 上下文数据
Resources provide structured access to information that the host application can retrieve and provide to AI models as context.
资源为宿主应用程序提供结构化访问信息，应用程序可以获取这些信息并作为上下文提供给 AI 模型。
​
Overview  概述
Resources expose data from files, APIs, databases, or any other source that an AI needs to understand context. Applications can access this information directly and decide how to use it - whether that’s selecting relevant portions, searching with embeddings, or passing it all to the model.
资源从文件、API、数据库或其他 AI 需要理解上下文的任何来源中暴露数据。应用程序可以直接访问这些信息并决定如何使用它——无论是选择相关部分、使用嵌入进行搜索，还是将所有信息传递给模型。
Resources use URI-based identification, with each resource having a unique URI such as file:///path/to/document.md. They declare MIME types for appropriate content handling and support two discovery patterns: direct resources with fixed URIs, and resource templates with parameterized URIs.
资源使用基于 URI 的识别，每个资源都有一个唯一的 URI，例如 file:///path/to/document.md 。它们声明 MIME 类型以进行适当的 内容处理，并支持两种发现模式：具有固定 URI 的直接资源，以及具有参数化 URI 的资源模板。
Resource Templates enable dynamic resource access through URI templates. A template like travel://activities/{city}/{category} would access filtered activity data by substituting both {city} and {category} parameters. For example, travel://activities/barcelona/museums would return all museums in Barcelona. Resource Templates include metadata such as title, description, and expected MIME type, making them discoverable and self-documenting.
资源模板通过 URI 模板实现动态资源访问。例如，模板 travel://activities/{city}/{category} 通过替换 {city} 和 {category} 参数来访问过滤后的活动数据。比如， travel://activities/barcelona/museums 会返回巴塞罗那的所有博物馆。资源模板包含标题、描述和预期 MIME 类型等元数据，使其可发现且自描述。
Protocol operations:  协议操作：
Method  方法	Purpose  目的	Returns  返回
resources/list	List available direct resources
列出可用直接资源	Array of resource descriptors
资源描述符数组
resources/templates/list	Discover resource templates
发现资源模板	Array of resource template definitions
资源模板定义数组
resources/read	Retrieve resource contents
获取资源内容	Resource data with metadata
带元数据的资源数据
resources/subscribe	Monitor resource changes  监控资源变化	Subscription confirmation
订阅确认
​
Example: Accessing Context Data
示例：访问上下文数据
Continuing with the travel planning example, resources provide the AI application with access to relevant information:
继续以旅行规划为例，资源为 AI 应用程序提供访问相关信息的方式：
Calendar data (calendar://events/2024) - To check availability
日历数据（ calendar://events/2024 ）- 用于检查可用性
Travel documents (file:///Documents/Travel/passport.pdf) - For important information
旅行文件（ file:///Documents/Travel/passport.pdf ）- 用于重要信息
Previous itineraries (trips://history/barcelona-2023) - User selects which past trip style to follow
之前的行程（ trips://history/barcelona-2023 ）- 用户选择要遵循的过去旅行风格
Instead of manually copying this information, resources provide raw information to AI applications. The application can choose how to best handle the data. Applications might choose to select a subset of data, using embeddings or keyword search, or pass the raw data from a resource directly to a model. In our example, during the planning phase, the AI application can pass the calendar data, weather data and travel preferences, so that the model can check availability, look up weather patterns, and reference travel preferences.
与其手动复制这些信息，资源会向 AI 应用程序提供原始数据。应用程序可以选择最佳方式处理数据。应用程序可能会选择使用嵌入或关键词搜索来选取数据子集，或者直接将资源中的原始数据传递给模型。在我们的示例中，在规划阶段，AI 应用程序可以传递日历数据、天气数据和旅行偏好，以便模型可以检查可用性、查询天气模式并参考旅行偏好。
Resource Template Examples:
资源模板示例：

Copy
{
  "uriTemplate": "weather://forecast/{city}/{date}",
  "name": "weather-forecast",
  "title": "Weather Forecast",
  "description": "Get weather forecast for any city and date",
  "mimeType": "application/json"
}

{
  "uriTemplate": "travel://flights/{origin}/{destination}",
  "name": "flight-search",
  "title": "Flight Search",
  "description": "Search available flights between cities",
  "mimeType": "application/json"
}
These templates enable flexible queries. For weather data, users can access forecasts for any city/date combination. For flights, they can search routes between any two airports. When a user has input “NYC” as the origin airport and begins to input “Bar” as the destination airport, the system can suggest “Barcelona (BCN)” or “Barbados (BGI)”.
这些模板支持灵活的查询。对于天气数据，用户可以访问任意城市/日期组合的预报。对于航班，用户可以搜索任意两个机场之间的航线。当用户将“NYC”输入为 origin 机场，并开始输入“Bar”作为 destination 机场时，系统可以建议“Barcelona (BCN)”或“Barbados (BGI)”。
​
Parameter Completion  参数完成
Dynamic resources support parameter completion. For example:
动态资源支持参数补全。例如：
Typing “Par” as input for weather://forecast/{city} might suggest “Paris” or “Park City”
在 weather://forecast/{city} 中输入“Par”可能会提示“Paris”或“Park City”
The system helps discover valid values without requiring exact format knowledge
系统帮助发现有效值，无需了解精确格式
​
User Interaction Model  用户交互模型
Resources are application-driven, giving hosts flexibility in how they retrieve, process, and present available context. Common interaction patterns include tree or list views for browsing resources in familiar folder-like structures, search and filter interfaces for finding specific resources, automatic context inclusion based on heuristics or AI selection, and manual selection interfaces.
资源由应用程序驱动，使主机在获取、处理和呈现可用上下文方面具有灵活性。常见的交互模式包括用于在熟悉的类似文件夹结构中浏览资源的树形或列表视图、用于查找特定资源的搜索和过滤界面、基于启发式或 AI 选择的自动上下文包含，以及手动选择界面。
Applications are free to implement resource discovery through any interface pattern that suits their needs. The protocol doesn’t mandate specific UI patterns, allowing for resource pickers with preview capabilities, smart suggestions based on current conversation context, bulk selection for including multiple resources, or integration with existing file browsers and data explorers.
应用程序可以自由地通过任何适合其需求的接口模式实现资源发现。该协议不强制规定特定的 UI 模式，允许具有预览功能的资源选择器、基于当前对话上下文的智能建议、用于包含多个资源的批量选择，或与现有的文件浏览器和数据探索器集成。
​
Prompts - Interaction Templates
提示 - 交互模板
Prompts provide reusable templates. They allow MCP server authors to provide parameterized prompts for a domain, or showcase how to best use the MCP server.
提示提供可重用的模板。它们允许 MCP 服务器作者为特定领域提供参数化提示，或展示如何最佳使用 MCP 服务器。
​
Overview  概述
Prompts are structured templates that define expected inputs and interaction patterns. They are user-controlled, requiring explicit invocation rather than automatic triggering. Prompts can be context-aware, referencing available resources and tools to create comprehensive workflows. Like resources, prompts support parameter completion to help users discover valid argument values.
提示是定义预期输入和交互模式的结构化模板。它们由用户控制，需要显式调用而非自动触发。提示可以感知上下文，引用可用资源和工具来创建全面的流程。与资源类似，提示支持参数补全，以帮助用户发现有效的参数值。
Protocol operations:  协议操作：
Method  方法	Purpose  目的	Returns  返回
prompts/list	Discover available prompts
发现可用提示	Array of prompt descriptors
提示描述符数组
prompts/get	Retrieve prompt details  检索提示详情	Full prompt definition with arguments
带参数的完整提示定义
​
Example: Streamlined Workflows
示例：精简工作流程
Prompts provide structured templates for common tasks. In the travel planning context:
提示为常见任务提供结构化模板。在旅行规划情境中：
“Plan a vacation” prompt:
“计划一次假期”提示：

Copy
{
  "name": "plan-vacation",
  "title": "Plan a vacation",
  "description": "Guide through vacation planning process",
  "arguments": [
    { "name": "destination", "type": "string", "required": true },
    { "name": "duration", "type": "number", "description": "days" },
    { "name": "budget", "type": "number", "required": false },
    { "name": "interests", "type": "array", "items": { "type": "string" } }
  ]
}
Rather than unstructured natural language input, the prompt system enables:
与其非结构化的自然语言输入，提示系统可以实现：
Selection of the “Plan a vacation” template
选择“计划假期”模板
Structured input: Barcelona, 7 days, $3000, [“beaches”, “architecture”, “food”]
结构化输入：巴塞罗那，7 天，3000 美元，[“海滩”，“建筑”，“美食”]
Consistent workflow execution based on the template
基于模板执行一致的工作流程
​
User Interaction Model  用户交互模型
Prompts are user-controlled, requiring explicit invocation. Applications typically expose prompts through various UI patterns such as slash commands (typing ”/” to see available prompts like /plan-vacation), command palettes for searchable access, dedicated UI buttons for frequently used prompts, or context menus that suggest relevant prompts.
提示由用户控制，需要显式调用。应用程序通常通过各种 UI 模式展示提示，例如斜杠命令（输入“/”查看可用提示，如/plan-vacation）、可搜索的命令面板、用于常用提示的专用 UI 按钮，或建议相关提示的上下文菜单。
The protocol gives implementers freedom to design interfaces that feel natural within their application. Key principles include easy discovery of available prompts, clear descriptions of what each prompt does, natural argument input with validation, and transparent display of the prompt’s underlying template.
该协议为开发者提供了自由设计在其应用程序中感觉自然的界面的空间。关键原则包括易于发现可用的提示、清晰描述每个提示的作用、自然的参数输入与验证，以及透明显示提示的底层模板。
​
How It All Works Together
这一切是如何协同工作的
The real power of MCP emerges when multiple servers work together, combining their specialized capabilities through a unified interface.
MCP 的真正强大之处体现在多个服务器协同工作时，它们通过统一接口结合各自的专业能力。
​
Example: Multi-Server Travel Planning
示例：多服务器旅行规划
Consider an AI application with three connected servers:
考虑一个包含三台连接服务器的 AI 应用程序：
Travel Server - Handles flights, hotels, and itineraries
旅行服务器 - 处理航班、酒店和行程
Weather Server - Provides climate data and forecasts
天气服务器 - 提供气候数据和预报
Calendar/Email Server - Manages schedules and communications
日历/电子邮件服务器 - 管理日程和通信
​
The Complete Flow  完整流程
User invokes a prompt with parameters:
用户调用带参数的提示：

Copy
{
  "prompt": "plan-vacation",
  "arguments": {
    "destination": "Barcelona",
    "departure_date": "2024-06-15",
    "return_date": "2024-06-22",
    "budget": 3000,
    "travelers": 2
  }
}
User selects resources to include:
用户选择要包含的资源：
calendar://my-calendar/June-2024 (from Calendar Server)
calendar://my-calendar/June-2024 (来自日历服务器)
travel://preferences/europe (from Travel Server)   travel://preferences/europe (来自旅行服务器)
travel://past-trips/Spain-2023 (from Travel Server)   travel://past-trips/Spain-2023 (来自旅行服务器)
AI processes the request: The AI first reads all selected resources to gather context. From the calendar, it identifies available dates. From travel preferences, it learns preferred airlines and hotel types. From past trips, it discovers previously enjoyed locations. From weather data, it checks climate conditions for the travel period. Using this context, the AI then requests user approval to execute a series of coordinated actions: searching for flights from NYC to Barcelona, finding hotels within the specified budget, creating a calendar event for the trip duration, and sending confirmation emails with the trip details.




Build an MCP Server

Copy page

Get started building your own server to use in Claude for Desktop and other clients.

In this tutorial, we’ll build a simple MCP weather server and connect it to a host, Claude for Desktop. We’ll start with a basic setup, and then progress to more complex use cases.
​
What we’ll be building
Many LLMs do not currently have the ability to fetch the forecast and severe weather alerts. Let’s use MCP to solve that!
We’ll build a server that exposes two tools: get_alerts and get_forecast. Then we’ll connect the server to an MCP host (in this case, Claude for Desktop):


Servers can connect to any client. We’ve chosen Claude for Desktop here for simplicity, but we also have guides on building your own client as well as a list of other clients here.
​
Core MCP Concepts
MCP servers can provide three main types of capabilities:
Resources: File-like data that can be read by clients (like API responses or file contents)
Tools: Functions that can be called by the LLM (with user approval)
Prompts: Pre-written templates that help users accomplish specific tasks
This tutorial will primarily focus on tools.
Python
Node
Java
Kotlin
C#
Let’s get started with building our weather server! You can find the complete code for what we’ll be building here.
​
Prerequisite knowledge
This quickstart assumes you have familiarity with:
Python
LLMs like Claude
​
Logging in MCP Servers
When implementing MCP servers, be careful about how you handle logging:
For STDIO-based servers: Never write to standard output (stdout). This includes:
print() statements in Python
console.log() in JavaScript
fmt.Println() in Go
Similar stdout functions in other languages
Writing to stdout will corrupt the JSON-RPC messages and break your server.
For HTTP-based servers: Standard output logging is fine since it doesn’t interfere with HTTP responses.
​
Best Practices
Use a logging library that writes to stderr or files.
​
Quick Examples

Copy
# ❌ Bad (STDIO)
print("Processing request")

# ✅ Good (STDIO)
import logging
logging.info("Processing request")
​
System requirements
Python 3.10 or higher installed.
You must use the Python MCP SDK 1.2.0 or higher.
​
Set up your environment
First, let’s install uv and set up our Python project and environment:

macOS/Linux

Windows

Copy
curl -LsSf https://astral.sh/uv/install.sh | sh
Make sure to restart your terminal afterwards to ensure that the uv command gets picked up.
Now, let’s create and set up our project:

macOS/Linux

Windows

Copy
# Create a new directory for our project
uv init weather
cd weather

# Create virtual environment and activate it
uv venv
source .venv/bin/activate

# Install dependencies
uv add "mcp[cli]" httpx

# Create our server file
touch weather.py
Now let’s dive into building your server.
​
Building your server
​
Importing packages and setting up the instance
Add these to the top of your weather.py:

Copy
from typing import Any
import httpx
from mcp.server.fastmcp import FastMCP

# Initialize FastMCP server
mcp = FastMCP("weather")

# Constants
NWS_API_BASE = "https://api.weather.gov"
USER_AGENT = "weather-app/1.0"
The FastMCP class uses Python type hints and docstrings to automatically generate tool definitions, making it easy to create and maintain MCP tools.
​
Helper functions
Next, let’s add our helper functions for querying and formatting the data from the National Weather Service API:

Copy
async def make_nws_request(url: str) -> dict[str, Any] | None:
    """Make a request to the NWS API with proper error handling."""
    headers = {
        "User-Agent": USER_AGENT,
        "Accept": "application/geo+json"
    }
    async with httpx.AsyncClient() as client:
        try:
            response = await client.get(url, headers=headers, timeout=30.0)
            response.raise_for_status()
            return response.json()
        except Exception:
            return None

def format_alert(feature: dict) -> str:
    """Format an alert feature into a readable string."""
    props = feature["properties"]
    return f"""
Event: {props.get('event', 'Unknown')}
Area: {props.get('areaDesc', 'Unknown')}
Severity: {props.get('severity', 'Unknown')}
Description: {props.get('description', 'No description available')}
Instructions: {props.get('instruction', 'No specific instructions provided')}
"""
​
Implementing tool execution
The tool execution handler is responsible for actually executing the logic of each tool. Let’s add it:

Copy
@mcp.tool()
async def get_alerts(state: str) -> str:
    """Get weather alerts for a US state.

    Args:
        state: Two-letter US state code (e.g. CA, NY)
    """
    url = f"{NWS_API_BASE}/alerts/active/area/{state}"
    data = await make_nws_request(url)

    if not data or "features" not in data:
        return "Unable to fetch alerts or no alerts found."

    if not data["features"]:
        return "No active alerts for this state."

    alerts = [format_alert(feature) for feature in data["features"]]
    return "\n---\n".join(alerts)

@mcp.tool()
async def get_forecast(latitude: float, longitude: float) -> str:
    """Get weather forecast for a location.

    Args:
        latitude: Latitude of the location
        longitude: Longitude of the location
    """
    # First get the forecast grid endpoint
    points_url = f"{NWS_API_BASE}/points/{latitude},{longitude}"
    points_data = await make_nws_request(points_url)

    if not points_data:
        return "Unable to fetch forecast data for this location."

    # Get the forecast URL from the points response
    forecast_url = points_data["properties"]["forecast"]
    forecast_data = await make_nws_request(forecast_url)

    if not forecast_data:
        return "Unable to fetch detailed forecast."

    # Format the periods into a readable forecast
    periods = forecast_data["properties"]["periods"]
    forecasts = []
    for period in periods[:5]:  # Only show next 5 periods
        forecast = f"""
{period['name']}:
Temperature: {period['temperature']}°{period['temperatureUnit']}
Wind: {period['windSpeed']} {period['windDirection']}
Forecast: {period['detailedForecast']}
"""
        forecasts.append(forecast)

    return "\n---\n".join(forecasts)
​
Running the server
Finally, let’s initialize and run the server:

Copy
if __name__ == "__main__":
    # Initialize and run the server
    mcp.run(transport='stdio')
Your server is complete! Run uv run weather.py to start the MCP server, which will listen for messages from MCP hosts.
Let’s now test your server from an existing MCP host, Claude for Desktop.
​
Testing your server with Claude for Desktop
Claude for Desktop is not yet available on Linux. Linux users can proceed to the Building a client tutorial to build an MCP client that connects to the server we just built.
First, make sure you have Claude for Desktop installed. You can install the latest version here. If you already have Claude for Desktop, make sure it’s updated to the latest version.
We’ll need to configure Claude for Desktop for whichever MCP servers you want to use. To do this, open your Claude for Desktop App configuration at ~/Library/Application Support/Claude/claude_desktop_config.json in a text editor. Make sure to create the file if it doesn’t exist.
For example, if you have VS Code installed:

macOS/Linux

Windows

Copy
code ~/Library/Application\ Support/Claude/claude_desktop_config.json
You’ll then add your servers in the mcpServers key. The MCP UI elements will only show up in Claude for Desktop if at least one server is properly configured.
In this case, we’ll add our single weather server like so:

macOS/Linux

Windows

Copy
{
  "mcpServers": {
    "weather": {
      "command": "uv",
      "args": [
        "--directory",
        "/ABSOLUTE/PATH/TO/PARENT/FOLDER/weather",
        "run",
        "weather.py"
      ]
    }
  }
}
You may need to put the full path to the uv executable in the command field. You can get this by running which uv on macOS/Linux or where uv on Windows.
Make sure you pass in the absolute path to your server. You can get this by running pwd on macOS/Linux or cd on Windows Command Prompt. On Windows, remember to use double backslashes (\\) or forward slashes (/) in the JSON path.
This tells Claude for Desktop:
There’s an MCP server named “weather”
To launch it by running uv --directory /ABSOLUTE/PATH/TO/PARENT/FOLDER/weather run weather.py
Save the file, and restart Claude for Desktop.
​
Test with commands
Let’s make sure Claude for Desktop is picking up the two tools we’ve exposed in our weather server. You can do this by looking for the “Search and tools”  icon:

After clicking on the slider icon, you should see two tools listed:

If your server isn’t being picked up by Claude for Desktop, proceed to the Troubleshooting section for debugging tips.
If the tool settings icon has shown up, you can now test your server by running the following commands in Claude for Desktop:
What’s the weather in Sacramento?
What are the active weather alerts in Texas?


Since this is the US National Weather service, the queries will only work for US locations.
​
What’s happening under the hood
When you ask a question:
The client sends your question to Claude
Claude analyzes the available tools and decides which one(s) to use
The client executes the chosen tool(s) through the MCP server
The results are sent back to Claude
Claude formulates a natural language response
The response is displayed to you!


Inspector

Copy page

In-depth guide to using the MCP Inspector for testing and debugging Model Context Protocol servers

The MCP Inspector is an interactive developer tool for testing and debugging MCP servers. While the Debugging Guide covers the Inspector as part of the overall debugging toolkit, this document provides a detailed exploration of the Inspector’s features and capabilities.
​
Getting started
​
Installation and basic usage
The Inspector runs directly through npx without requiring installation:

Copy
npx @modelcontextprotocol/inspector <command>

Copy
npx @modelcontextprotocol/inspector <command> <arg1> <arg2>
​
Inspecting servers from NPM or PyPi
A common way to start server packages from NPM or PyPi.
NPM package
PyPi package

Copy
npx -y @modelcontextprotocol/inspector npx <package-name> <args>
# For example
npx -y @modelcontextprotocol/inspector npx @modelcontextprotocol/server-filesystem /Users/username/Desktop
​
Inspecting locally developed servers
To inspect servers locally developed or downloaded as a repository, the most common way is:
TypeScript
Python

Copy
npx @modelcontextprotocol/inspector node path/to/server/index.js args...
Please carefully read any attached README for the most accurate instructions.
​
Feature overview

The MCP Inspector interface

The Inspector provides several features for interacting with your MCP server:
​
Server connection pane
Allows selecting the transport for connecting to the server
For local servers, supports customizing the command-line arguments and environment
​
Resources tab
Lists all available resources
Shows resource metadata (MIME types, descriptions)
Allows resource content inspection
Supports subscription testing
​
Prompts tab
Displays available prompt templates
Shows prompt arguments and descriptions
Enables prompt testing with custom arguments
Previews generated messages
​
Tools tab
Lists available tools
Shows tool schemas and descriptions
Enables tool testing with custom inputs
Displays tool execution results
​
Notifications pane
Presents all logs recorded from the server
Shows notifications received from the server
​
Best practices
​
Development workflow
Start Development
Launch Inspector with your server
Verify basic connectivity
Check capability negotiation
Iterative testing
Make server changes
Rebuild the server
Reconnect the Inspector
Test affected features
Monitor messages
Test edge cases
Invalid inputs
Missing prompt arguments
Concurrent operations
Verify error handling and error responses
